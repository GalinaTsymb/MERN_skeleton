import User from '../models/user.model'
import jwt from 'jsonwebtoken'
import expressJwt from 'express-jwt'
import config from './../../config/config'


/*Объект запроса POST получает адрес электронной почты и пароль в req.body.
    Этот адрес электронной почты используется для извлечения соответствующего пользователя
из базы данных. Затем метод аутентификации по паролю, определенный в UserSchema,
    используется для проверки пароля, полученного в req.body от клиента.*/

const signin = async (req, res) => {
    try {
        let user = await User.findOne({
            "email": req.body.email
        });
        if (!user)
            return res.status('401').json({
                error: "User not found"
            });

        if (!user.authenticate(req.body.password)) {
            return res.status('401').send({
                error: "Email and password don't match."
            })
        }

        /*Если пароль успешно проверен, модуль JWT используется для создания подписанного JWT с использованием
        секретного ключа и значения _id пользователя.*/

        const token = jwt.sign({
            _id: user._id
        }, config.jwtSecret);

        res.cookie("t", token, {
            expire: new Date() + 9999
        });


        /*Затем подписанный JWT возвращается аутентифицированному клиенту вместе с данными пользователя.
            При желании мы также можем установить токен в файл cookie в объекте ответа, чтобы он был доступен
        на стороне клиента, если файлы cookie являются выбранной формой хранилища JWT.
            На стороне клиента этот токен должен быть прикреплен как заголовок авторизации при запросе
        защищенных маршрутов с сервера. Чтобы выйти из системы, клиентская сторона может просто удалить
        этот токен в зависимости от того, как он хранится. В следующем разделе мы узнаем, как использовать
        конечную точку API выхода для очистки файла cookie, содержащего токен.*/

        return res.json({
            token,
            user: {
                _id: user._id,
                name: user.name,
                email: user.email
            }
        })

    } catch (err) {

        return res.status('401').json({
            error: "Could not sign in"
        })

    }
};


/*Функция выхода очищает ответный cookie, содержащий подписанный JWT. Это необязательная конечная точка
и на самом деле не требуется для целей аутентификации, если файлы cookie вообще не используются
во внешнем интерфейсе.*/


/*При использовании JWT за хранение пользовательского состояния отвечает клиент, и кроме файлов cookie
существует несколько вариантов хранения на стороне клиента. При выходе клиенту необходимо удалить токен
на стороне клиента, чтобы установить, что пользователь больше не аутентифицирован.
    На стороне сервера мы можем использовать и проверять токен, сгенерированный при входе в систему,
    для защиты маршрутов, к которым нельзя получить доступ без действительной аутентификации.*/

const signout = (req, res) => {
    res.clearCookie("t");
    return res.status('200').json({
        message: "signed out"
    })
};

/*Модуль express-jwt - это промежуточное программное обеспечение, которое проверяет веб-токены JSON.*/

/*Мы определим два метода контроллера аутентификации, называемые requireSignin и hasAuthorization,
    оба из которых будут добавлены к объявлениям пользовательского маршрута, которые необходимо
защитить с помощью аутентификации и авторизации.*/


/*Метод requireSignin использует express-jwt для проверки того, что входящий запрос имеет допустимый JWT
в заголовке авторизации. Если токен действителен, он добавляет проверенный идентификатор пользователя
в ключе «auth» к объекту запроса; в противном случае возникает ошибка аутентификации.*/

/*Мы можем добавить requireSignin к любому маршруту, который должен быть защищен от доступа без аутентификации.*/
const requireSignin = expressJwt({
    secret: config.jwtSecret,
    userProperty: 'auth'
});

/*Для некоторых защищенных маршрутов, таких как обновление и удаление, помимо проверки аутентификации
мы также хотим убедиться, что запрашивающий пользователь обновляет или удаляет только свою собственную
информацию о пользователе.*/

/*функция hasAuthorization, будет проверять,
    совпадает ли аутентифицированный пользователь с пользователем, который обновляется или
удаляется, прежде чем соответствующая функция контроллера CRUD будет разрешена для продолжения.*/

/*Объект req.auth заполняется с помощью express-jwt в requireSignin после проверки аутентификации,
    а req.profile заполняется функцией userByID в user.controller.js. Мы добавим функцию hasAuthorization
к маршрутам, требующим как аутентификации, так и авторизации.*/

const hasAuthorization = (req, res, next) => {
    const authorized = req.profile && req.auth && req.profile._id == req.auth._id
    if (!(authorized)) {
        return res.status('403').json({
            error: "User is not authorized"
        })
    }
    next()
};

export default {
    signin,
    signout,
    requireSignin,
    hasAuthorization
}
